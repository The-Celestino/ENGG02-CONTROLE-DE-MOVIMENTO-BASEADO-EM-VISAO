#!/usr/bin/env python3
"""
Nó (node) em Python para ler dados da câmera
"""

import sys, time
import numpy as np
import cv2 as cv
import roslib
import rospy
from sensor_msgs.msg import CompressedImage  # Mensagens ROS

print(('versão do opencv: ', cv.__version__))

class image_read:
    def __init__(self):
        # Define o tópico do subscriber (assinante)
        self.subscriber = rospy.Subscriber(("/myur5/camera1/image_raw/compressed"), 
                                           CompressedImage, self.callback, queue_size=1)

    def callback(self, ros_data):
        global coordenates, n_b, n_g, n_r
        coordenates = []
        def dibujar(mask, color):
            n = 0
            coord = []
            # Encontra os contornos na máscara de cor
            contours, hiterachy = cv.findContours(mask, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_NONE)

            for c in contours:
                area = cv.contourArea(c)
                # Filtra contornos pequenos para remover ruído
                if area > 100:
                    n = n + 1
                    m = cv.moments(c)
                    if m["m00"] == 0:
                        m["m00"] = 1
                    # Calcula o centroide (centro) do contorno
                    x = int(m["m10"] / m["m00"])
                    y = int(m["m01"] / m["m00"])
                    # Desenha um círculo no centroide
                    cv.circle(frame, (x, y), 3, color, -1)
                    font = cv.FONT_HERSHEY_SIMPLEX
                    # Escreve as coordenadas na imagem
                    cv.putText(frame, "(" + str(x) + ", " + str(y) + ")", (x + 28, y), font, 0.5, color, 1, cv.LINE_AA)
                    # Desenha o contorno do objeto
                    convexhull = cv.convexHull(c)
                    cv.drawContours(frame, [convexhull], 0, color, 3)
                    # Adiciona as coordenadas à lista
                    coord.append(x)
                    coord.append(y)
            return n, coord


        """Aqui as imagens são lidas e processadas"""
        # --- Limites de Cor no Espaço HSV ---
        
        # VERMELHO (dividido em duas faixas para cobrir a transição do matiz)
        redBajo1 = np.array([0, 100, 20], np.uint8)
        redAlto1 = np.array([8, 255, 255], np.uint8)
        redBajo2 = np.array([175, 100, 20], np.uint8)
        redAlto2 = np.array([179, 255, 255], np.uint8)

        # AZUL
        blueBajo = np.array([100, 100, 20], np.uint8)
        blueAlto = np.array([125, 255, 255], np.uint8)

        # VERDE
        greenBajo = np.array([45, 100, 20], np.uint8)
        greenAlto = np.array([95, 255, 255], np.uint8)

        # Decodifica os dados da imagem ROS para um formato que o OpenCV entende
        np_arr = np.frombuffer(ros_data.data, np.uint8)
        frame = cv.imdecode(np_arr, cv.IMREAD_COLOR)

        # Converte a imagem de BGR para HSV para facilitar a detecção de cor
        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
        
        # Cria as máscaras para cada cor
        maskRed1 = cv.inRange(hsv, redBajo1, redAlto1)
        maskRed2 = cv.inRange(hsv, redBajo2, redAlto2)
        maskRed = cv.bitwise_or(maskRed1, maskRed2) # Combina as duas máscaras de vermelho
        maskBlue = cv.inRange(hsv, blueBajo, blueAlto)
        maskGreen = cv.inRange(hsv, greenBajo, greenAlto)

        piec_blue = []
        piec_green = []  # Vetores que armazenam a posição em pixels de cada uma das peças
        piec_red = []

        # Processa cada máscara para encontrar e desenhar os objetos
        n_b, piec_blue = dibujar(maskBlue, (255, 0, 0)) # Cor BGR para azul
        coordenates.append(piec_blue)
        n_g, piec_green = dibujar(maskGreen, (0, 255, 0)) # Cor BGR para verde
        coordenates.append(piec_green)
        n_r, piec_red = dibujar(maskRed, (0, 0, 255)) # Cor BGR para vermelho
        coordenates.append(piec_red)

        # Mostra a imagem processada em uma janela
        cv.imshow('frame', frame)
        cv.waitKey(2)
    
    def rev_coord(self):
        """Retorna as contagens de objetos e suas coordenadas."""
        global coordenates, n_b, n_g, n_r
        return n_b, n_g, n_r, coordenates
        
    
def main(args):
    """Inicializa e encerra o nó (node) do ROS"""
    ic = image_read()
    rospy.init_node('image_read', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print('Encerrando o nó de leitura de imagem do ROS')
        cv.destroyAllWindows()

if __name__ == '__main__':
    main(sys.argv)